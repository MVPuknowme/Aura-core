from modules.wallet.connector import WalletConnector

wc = WalletConnector()
balance = wc.get_balance()
transactions = wc.get_transactions()
import os
import logging
from dotenv import load_dotenv
from coinbase.wallet.client import Client

load_dotenv()

API_KEY = os.getenv("COINBASE_API_KEY")
API_SECRET = os.getenv("COINBASE_API_SECRET")
PASSPHRASE = os.getenv("COINBASE_PASSPHRASE")
WALLET_ADDRESS = os.getenv("WALLET_ADDRESS")

# Set up logging
logging.basicConfig(
    filename="wallet_connector.log",
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s"
)

class WalletConnector:
    def __init__(self):
        self.client = Client(API_KEY, API_SECRET)

    def get_balance(self):
        try:
            account = self.client.get_account(import requests

def lightning_pay(invoice, simulate=False, env=None):
    if simulate:
        return {
            "status": "SIMULATED",
            "rail": "lightning",
            "invoice": invoice
        }

    lnbits_url = env.get("LNBITS_URL")
    lnbits_key = env.get("LNBITS_KEY")

    r = requests.post(
        f"{lnbits_url}/api/v1/payments",
        json={"out": True, "bolt11": invoice},
        headers={"X-Api-Key": lnbits_key}
    )

    if r.status_code != 200:
        return {
            "status": "FAILED",
            "rail": "lightning",
            "error": r.text
        }

    data = r.json()
    return {
        "status": "SETTLED",
        "rail": "lightning",
        "payment_hash": data.get("payment_hash")
    }
)
            balance = account.balance.amount
            logging.info(f"Balance for {WALLET_ADDRESS}: {balance}")
            return balance
        except Exception as e:
            logging.error(f"Failed to retrieve balance: {e}")
            return None

    def get_transactions(self):
        try:
            account = self.client.get_account(WALLET_ADDRESS)
            txs = account.get_transactions()
            for tx in txs.data:
                logging.info(f"Transaction: {tx.id} | {tx.status} | {tx.amount.amount} {tx.amount.currency}")
            return txs.data
        except Exception as e:
            logging.error(f"Failed to fetch transactions: {e}")
            return []

    def send_payment(self, to_address, amount, currency="USD"):
        try:
            account = self.client.get_account(WALLET_ADDRESS)
            tx = account.send_money(to=to_address, amount=amount, currency=currency)
            logging.info(f"Sent {amount} {currency} to {to_address}. TxID: {tx.id}")
            return tx
        except Exception as e:
            logging.error(f"Payment failed: {e}")
            return None

if __name__ == "__main__":
    wc = WalletConnector()
    wc.get_balance()
    wc.get_transactions()
name: Wallet Sync

on:
  schedule:
    - cron: '*/5 * * * *'  # every 5 minutes
  workflow_dispatch:        # allows manual trigger

jobs:
  sync-wallet:
    runs-on: ubuntu-latest
    env:
      COINBASE_API_KEY: ${{ secrets.COINBASE_API_KEY }}
      COINBASE_API_SECRET: ${{ secrets.COINBASE_API_SECRET }}
      COINBASE_PASSPHRASE: ${{ secrets.COINBASE_PASSPHRASE }}
      WALLET_ADDRESS: ${{ secrets.WALLET_ADDRESS }}

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install Requirements
        run: |
          pip install -r modules/wallet/requirements.txt

      - name: Run Wallet Sync
        run: |
          python modules/wallet/connector.py

      - name: Commit Audit Log
        run: |
          git config --global user.name "Aura-Core Bot"
          git config --global user.email "aura-core-bot@example.com"
          git add modules/wallet/wallet_connector.log
          git commit -m "Update wallet audit log"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify if Balance Changed
        run: |
          last_balance=$(tail -n 1 modules/wallet/wallet_connector.log | awk '{print $NF}')
          echo "Current wallet balance: $last_balance"
diff --git a/lib/aura_wallet_core.dart b/lib/aura_wallet_core.dart
index 2aed6c8073060160971e7c8a41caee015125b926..5574a357723cf26791db940e44042631f38a4224 100644
--- a/lib/aura_wallet_core.dart
+++ b/lib/aura_wallet_core.dart
@@ -1,49 +1,63 @@
 import 'src/aura_internal_wallet_ipml.dart';
 import 'src/config_options/biometric_options.dart';
+import 'src/config_options/currency_conversion_config.dart';
+import 'src/config_options/payment_processing_rules.dart';
 import 'src/constants/aura_constants.dart';
 import 'src/entities/aura_wallet.dart';
 import 'src/env/env.dart';
 
 /// An abstract class representing the core functionality of an Aura wallet.
 abstract class AuraWalletCore {
   /// Factory constructor for creating an instance of [AuraWalletCore].
   factory AuraWalletCore.create({
     required AuraWalletCoreEnvironment environment,
     BiometricOptions? biometricOptions,
+    PaymentProcessingRules paymentRules = const PaymentProcessingRules(),
+    CurrencyConversionConfig currencyConversionConfig =
+        const CurrencyConversionConfig(),
   }) {
-    return _instance(environment, biometricOptions);
+    return _instance(
+      environment,
+      biometricOptions,
+      paymentRules,
+      currencyConversionConfig,
+    );
   }
 
   /// Internal method to create an instance of [AuraWalletCore].
   static AuraWalletCore _instance(
     AuraWalletCoreEnvironment environment,
     BiometricOptions? biometricOptions,
+    PaymentProcessingRules paymentRules,
+    CurrencyConversionConfig currencyConversionConfig,
   ) =>
       AuraWalletCoreImpl(
         environment: environment,
         biometricOptions: biometricOptions,
+        paymentRules: paymentRules,
+        currencyConversionConfig: currencyConversionConfig,
       );
 
   /// Generates a random HD wallet.
   ///
   /// Returns an [ComprehensiveWallet] containing the wallet information.
   Future<ComprehensiveWallet> createRandomHDWallet();
 
   /// Restores a HD wallet from a passphrase.
   ///
   /// [passPhrase]: The passphrase used to restore the wallet.
   /// [walletName]: The name of the wallet (default is [CONST_DEFAULT_WALLET_NAME]).
   ///
   /// Returns an [AuraWallet] instance.
   Future<AuraWallet> restoreHDWallet({
     required String passPhrase,
     String walletName = CONST_DEFAULT_WALLET_NAME,
   });
 
   /// Loads a previously stored wallet.
   ///
   /// [walletName]: The name of the wallet to load (default is [CONST_DEFAULT_WALLET_NAME]).
   ///
   /// Returns an [AuraWallet] instance or `null` if no wallet is found.
   Future<AuraWallet?> loadStoredWallet({
     String walletName = CONST_DEFAULT_WALLET_NAME,
diff --git a/lib/src/aura_internal_wallet_ipml.dart b/lib/src/aura_internal_wallet_ipml.dart
index 61207026a395ea4d6c3e41b2a089cb99a13067bc..6fc497adb4cee1f05fd993b7ceee04a13cbad4d0 100644
--- a/lib/src/aura_internal_wallet_ipml.dart
+++ b/lib/src/aura_internal_wallet_ipml.dart
@@ -1,52 +1,59 @@
 import 'package:alan/alan.dart';
 
 import 'package:aura_wallet_core/src/utils/aura_wallet_utils.dart';
 
 import 'package:flutter/services.dart';
 import 'package:hex/hex.dart';
 import '../aura_wallet_core.dart';
 import 'config_options/biometric_options.dart';
+import 'config_options/currency_conversion_config.dart';
+import 'config_options/payment_processing_rules.dart';
 import 'constants/aura_constants.dart';
 import 'constants/error_constants.dart';
 import 'core/exceptions/aura_internal_exception.dart';
 
 import 'core/repo/store_house.dart';
 import 'core/utils/aura_inapp_wallet_helper.dart';
 import 'core/utils/aura_internal_storage.dart';
 import 'entities/aura_wallet.dart';
 import 'entities/aura_wallet_impl.dart';
 import 'env/env.dart';
 
 class AuraWalletCoreImpl implements AuraWalletCore {
   AuraWalletCoreImpl({
     required AuraWalletCoreEnvironment environment,
     required BiometricOptions? biometricOptions,
+    required PaymentProcessingRules paymentRules,
+    required CurrencyConversionConfig currencyConversionConfig,
   }) {
-    Storehouse.environment = environment;
-    Storehouse.networkInfo = AuraWalletUtil.getNetworkInfo(environment);
-    Storehouse.storage = AuraInternalStorage(biometricOptions);
+    Storehouse.makeDI(
+      environment,
+      biometricOptions,
+      paymentRules,
+      currencyConversionConfig,
+    );
   }
 
   @override
   Future<ComprehensiveWallet> createRandomHDWallet({
     String walletName = CONST_DEFAULT_WALLET_NAME,
   }) async {
     try {
       // Generate a random mnemonic with a strength of 256 bits.
       final List<String> mnemonic = Bip39.generateMnemonic(strength: 256);
 
       // Derive a wallet from the generated mnemonic.
       final Wallet wallet = Wallet.derive(mnemonic, Storehouse.networkInfo);
 
       // Create and return an AuraFullInfoAuraWalletImpl instance with the derived wallet details.
       return ComprehensiveWalletImpl(
         auraWallet: AuraWalletImpl(
           walletName: walletName,
           bech32Address: wallet.bech32Address,
           environment: Storehouse.environment,
         ),
         mnemonic: mnemonic.join(' '),
         privateKey: HEX.encode(wallet.privateKey),
       );
     } catch (e) {
       // Handle any exceptions that might occur during wallet creation.
diff --git a/lib/src/config_options/currency_conversion_config.dart b/lib/src/config_options/currency_conversion_config.dart
new file mode 100644
index 0000000000000000000000000000000000000000..df8a9a7fdf47150c732834291e31700974c99317
--- /dev/null
+++ b/lib/src/config_options/currency_conversion_config.dart
@@ -0,0 +1,59 @@
+class CurrencyConversionConfig {
+  /// Toggle for enabling the currency conversion system.
+  final bool enabled;
+
+  /// Name of the provider orchestrating conversions. Defaults to Phoenix Sun Pay.
+  final String providerName;
+
+  /// ISO currency code used as the base for conversion rates.
+  final String baseCurrency;
+
+  /// Map of ISO currency code to rate relative to [baseCurrency].
+  final Map<String, double> conversionRates;
+
+  /// Suggested refresh cadence for the rates (e.g., via cron or a scheduler).
+  final Duration refreshInterval;
+
+  /// Optional notes describing the configuration or data source.
+  final String? notes;
+
+  const CurrencyConversionConfig({
+    this.enabled = true,
+    this.providerName = 'PhoenixSunPay',
+    this.baseCurrency = 'USD',
+    this.conversionRates = const {},
+    this.refreshInterval = const Duration(hours: 1),
+    this.notes,
+  });
+
+  /// Returns `true` when a rate is available for [currencyCode].
+  bool supportsCurrency(String currencyCode) {
+    return conversionRates.containsKey(currencyCode.toUpperCase());
+  }
+
+  /// Returns the configured rate for [currencyCode], or `null` when missing.
+  double? rateFor(String currencyCode) {
+    return conversionRates[currencyCode.toUpperCase()];
+  }
+
+  /// Provides a validation hint when the system is disabled or misconfigured.
+  String? validationMessage({String? context, String? targetCurrency}) {
+    final List<String> issues = [];
+
+    if (!enabled) {
+      issues.add('Currency conversion is disabled');
+    }
+
+    if (targetCurrency != null && !supportsCurrency(targetCurrency)) {
+      issues.add('No rate is configured for $targetCurrency');
+    }
+
+    if (issues.isEmpty) {
+      return null;
+    }
+
+    final String prefix = context != null && context.isNotEmpty ? '$context: ' : '';
+    final String noteText = notes != null && notes!.isNotEmpty ? ' ($notes)' : '';
+    return '$prefix${issues.join('; ')}$noteText'.trim();
+  }
+}
diff --git a/lib/src/config_options/payment_processing_rules.dart b/lib/src/config_options/payment_processing_rules.dart
new file mode 100644
index 0000000000000000000000000000000000000000..d4e66ec67da9edc8f864234fc2a193599202c3ef
--- /dev/null
+++ b/lib/src/config_options/payment_processing_rules.dart
@@ -0,0 +1,39 @@
+class PaymentProcessingRules {
+  final bool plaidBridgeReady;
+  final bool mvpUknowMeAttached;
+  final bool paymentsEnabled;
+  final String? ruleNotes;
+
+  const PaymentProcessingRules({
+    this.plaidBridgeReady = true,
+    this.mvpUknowMeAttached = true,
+    this.paymentsEnabled = true,
+    this.ruleNotes,
+  });
+
+  bool get canProcessPayments =>
+      plaidBridgeReady && mvpUknowMeAttached && paymentsEnabled;
+
+  String? validationErrorMessage({String? context}) {
+    if (canProcessPayments) {
+      return null;
+    }
+
+    final List<String> unmetRules = [];
+    if (!plaidBridgeReady) {
+      unmetRules.add('Plaid bridge is not verified as healthy');
+    }
+    if (!mvpUknowMeAttached) {
+      unmetRules.add('Aura wallet is not attached to MVPuknowme');
+    }
+    if (!paymentsEnabled) {
+      unmetRules.add('Payment processing has been explicitly disabled');
+    }
+
+    final String scope = context != null ? '$context: ' : '';
+    final String noteText =
+        ruleNotes != null && ruleNotes!.isNotEmpty ? ' ($ruleNotes)' : '';
+
+    return '$scope${unmetRules.join('; ')}$noteText'.trim();
+  }
+}
diff --git a/lib/src/constants/error_constants.dart b/lib/src/constants/error_constants.dart
index ec9163a4f8d4b0349958ecdc4c04a840588941e3..05a4a58a9a6687efc51326a9042e57a7a01a34e5 100644
--- a/lib/src/constants/error_constants.dart
+++ b/lib/src/constants/error_constants.dart
@@ -26,26 +26,32 @@ class ErrorCode {
   static int NullPassphrase = 1008;
 
   // Error code for cases where there is an error with transaction signing.
   static int TransactionSigningError = 1009;
 
   // Error code for cases where no transactions are found.
   static int NoTransactionsFound = 1010;
 
   // Error code for cases where there is an error with transaction verification.
   static int TransactionVerificationError = 1011;
 
 // Error code for cases where wallet creation has failed.
   static int WalletCreationError = 1012;
 
   // Error code for cases where an invalid passphrase is encountered.
   static int InvalidPassphrase = 1013;
 
   // Error code for cases where wallet restoration has failed.
   static int WalletRestorationError = 1014;
 
   // Error code for general platform-related errors.
   static int PlatformError = 1015;
 
   // Error code for cases where there is an error with wallet loading.
   static int WalletLoadingError = 1016;
+
+  // Error code for cases where payment processing is blocked by integration rules.
+  static int PaymentProcessingNotAllowed = 1017;
+
+  // Error code for cases where currency conversion is unavailable or disabled.
+  static int CurrencyConversionUnavailable = 1018;
 }
diff --git a/lib/src/core/repo/store_house.dart b/lib/src/core/repo/store_house.dart
index d22f3625646e89af1fe21b28b6e579dbce0adf36..33bd9f36647856273ed348e51ea1e8b73611b78f 100644
--- a/lib/src/core/repo/store_house.dart
+++ b/lib/src/core/repo/store_house.dart
@@ -1,22 +1,34 @@
 import 'package:alan/alan.dart';
 import 'package:aura_wallet_core/src/config_options/biometric_options.dart';
+import 'package:aura_wallet_core/src/config_options/payment_processing_rules.dart';
 import 'package:aura_wallet_core/src/env/env.dart';
 import 'package:aura_wallet_core/src/utils/aura_wallet_utils.dart';
 import 'package:aura_wallet_core/storage_util.dart';
+import 'package:aura_wallet_core/src/config_options/currency_conversion_config.dart';
+
+import '../services/currency_conversion_service.dart';
 
 class Storehouse {
   Storehouse._();
 
   static late AuraWalletCoreEnvironment environment;
   static late NetworkInfo networkInfo;
   static late AuraInternalStorage storage;
+  static late PaymentProcessingRules paymentRules;
+  static late CurrencyConversionService currencyConversionService;
 
   static void makeDI(
     AuraWalletCoreEnvironment environment,
     BiometricOptions? biometricOptions,
+    PaymentProcessingRules paymentRules,
+    CurrencyConversionConfig currencyConversionConfig,
   ) {
     Storehouse.environment = environment;
     Storehouse.networkInfo = AuraWalletUtil.getNetworkInfo(environment);
     Storehouse.storage = AuraInternalStorage(biometricOptions);
+    Storehouse.paymentRules = paymentRules;
+    Storehouse.currencyConversionService = CurrencyConversionService(
+      config: currencyConversionConfig,
+    );
   }
 }
diff --git a/lib/src/core/services/currency_conversion_service.dart b/lib/src/core/services/currency_conversion_service.dart
new file mode 100644
index 0000000000000000000000000000000000000000..95bf8f1e22aa530ff943f8f8f27cc9ffdafd5259
--- /dev/null
+++ b/lib/src/core/services/currency_conversion_service.dart
@@ -0,0 +1,35 @@
+import '../../config_options/currency_conversion_config.dart';
+import '../../constants/error_constants.dart';
+import '../exceptions/aura_internal_exception.dart';
+
+class CurrencyConversionService {
+  final CurrencyConversionConfig config;
+
+  const CurrencyConversionService({required this.config});
+
+  /// Converts [amount] from the configured base currency to [targetCurrency].
+  ///
+  /// Throws [AuraInternalError] when conversion is disabled or the rate is missing.
+  double convert({required double amount, required String targetCurrency}) {
+    final String currencyCode = targetCurrency.toUpperCase();
+    final String? validation = config.validationMessage(
+      context: 'Currency conversion',
+      targetCurrency: currencyCode,
+    );
+
+    if (validation != null) {
+      throw AuraInternalError(
+        ErrorCode.CurrencyConversionUnavailable,
+        validation,
+      );
+    }
+
+    final double rate = config.rateFor(currencyCode)!;
+    return amount * rate;
+  }
+
+  /// Returns the configured rate for [targetCurrency] when available.
+  double? getRate(String targetCurrency) {
+    return config.rateFor(targetCurrency.toUpperCase());
+  }
+}
diff --git a/lib/src/entities/aura_wallet.dart b/lib/src/entities/aura_wallet.dart
index 754e1d55e93f5585ac541f822eb3a9c9f85957e1..38548abf9d2f244a4bc5dd5adedadf0151f234cf 100644
--- a/lib/src/entities/aura_wallet.dart
+++ b/lib/src/entities/aura_wallet.dart
@@ -45,38 +45,47 @@ abstract class AuraWallet {
     required String contractAddress,
     required Map<String, dynamic> query,
   });
 
   ///
   /// Return TxHash code corresponding execute message
   ///
   Future<String> makeInteractiveWriteSmartContract({
     required String contractAddress,
     required Map<String, dynamic> executeMessage,
     List<int>? funds,
     int? fee,
   });
 
   ///
   /// Verify status execute contract from txHash
   ///
   Future<bool> verifyTxHash({
     required String txHash,
   });
 
   ///
   /// Return mnemonic of user
   ///
   Future<String?> getWalletPassPhrase();
+
+  ///
+  /// Convert an [amount] from the configured base currency to [targetCurrency]
+  /// using the Phoenix Sun Pay conversion configuration.
+  ///
+  Future<double> convertAmount({
+    required double amount,
+    required String targetCurrency,
+  });
 }
 
 abstract class ComprehensiveWallet {
   final String mnemonic;
   final String privateKey;
   final AuraWallet auraWallet;
 
   ComprehensiveWallet({
     required this.mnemonic,
     required this.privateKey,
     required this.auraWallet,
   });
 }
diff --git a/lib/src/entities/aura_wallet_impl.dart b/lib/src/entities/aura_wallet_impl.dart
index ade4ae644666ffed304534d03e061ae4f52876d6..1812d2564bb274980686329d394fa57c93b440ce 100644
--- a/lib/src/entities/aura_wallet_impl.dart
+++ b/lib/src/entities/aura_wallet_impl.dart
@@ -8,105 +8,141 @@ import 'package:flutter/services.dart';
 import '../../aura_environment.dart';
 import '../../wallet_objects.dart';
 
 import 'package:alan/proto/cosmos/bank/v1beta1/export.dart';
 import 'package:alan/proto/cosmos/bank/v1beta1/export.dart' as bank;
 import 'package:alan/proto/cosmwasm/wasm/v1/export.dart' as cosMWasm;
 import 'package:alan/proto/cosmos/tx/v1beta1/export.dart' as auraTx;
 
 import '../constants/error_constants.dart';
 import '../core/exceptions/aura_internal_exception.dart';
 import '../core/repo/store_house.dart';
 import '../core/utils/aura_inapp_wallet_helper.dart';
 import '../core/utils/grpc_logger.dart';
 
 class AuraWalletImpl extends AuraWallet {
   const AuraWalletImpl({
     required String walletName,
     required String bech32Address,
     required AuraWalletCoreEnvironment environment,
   }) : super(
           walletName: walletName,
           bech32Address: bech32Address,
           environment: environment,
         );
 
+  void _ensurePaymentsAllowed(String context) {
+    final String? errorMessage =
+        Storehouse.paymentRules.validationErrorMessage(context: context);
+
+    if (errorMessage != null) {
+      throw AuraInternalError(
+        ErrorCode.PaymentProcessingNotAllowed,
+        errorMessage,
+      );
+    }
+  }
+
   /// Submits a signed transaction to the blockchain network.
   ///
   /// Returns `true` if the transaction is successfully broadcasted, otherwise `false`.
   ///
   /// Throws an exception in case of any errors during the transaction submission.
   ///
   /// [signedTransaction]: The signed transaction to be broadcasted.
   ///
   @override
   Future<bool> submitTransaction({required Tx signedTransaction}) async {
     try {
+      _ensurePaymentsAllowed('Submit transaction');
+
       var networkInfo = Storehouse.networkInfo;
       final txSender = TxSender.fromNetworkInfo(networkInfo);
       final response = await txSender.broadcastTx(signedTransaction);
 
       return response.isSuccessful;
     } catch (e) {
       // Handle any exceptions that might occur during the transaction submission.
       return false;
     }
   }
 
   /// Retrieves the balance of the wallet associated with the provided [walletName].
   ///
   /// Returns the wallet balance as a string.
   ///
   /// Throws an [AuraInternalError] if there's an error while fetching the balance.
   @override
   Future<String> checkWalletBalance() async {
     try {
       String denom = AuraWalletUtil.getDenom(environment);
       String? bech32Address =
           await Storehouse.storage.getWalletAddress(walletName: walletName);
 
       final req =
           bank.QueryBalanceRequest(address: bech32Address, denom: denom);
       var networkInfo = Storehouse.networkInfo;
 
       final client =
           bank.QueryClient(networkInfo.gRPCChannel, interceptors: [LogInter()]);
 
       final response = await client.balance(req);
 
       return response.balance.amount;
     } catch (e) {
       // Handle any exceptions that might occur while fetching the balance.
       throw AuraInternalError(
           500, 'Error fetching wallet balance: ${e.toString()}');
     }
   }
 
   Future<bool> checkMnemonic({required String mnemonic}) async {
     return Bip39.validateMnemonic(mnemonic.split(' '));
   }
 
+  @override
+  Future<double> convertAmount({
+    required double amount,
+    required String targetCurrency,
+  }) async {
+    try {
+      return Storehouse.currencyConversionService.convert(
+        amount: amount,
+        targetCurrency: targetCurrency,
+      );
+    } catch (e) {
+      if (e is AuraInternalError) {
+        rethrow;
+      }
+
+      throw AuraInternalError(
+        ErrorCode.CurrencyConversionUnavailable,
+        'Failed to convert currency: $e',
+      );
+    }
+  }
+
   /// Retrieves the transaction history of the wallet associated with the provided [walletName].
   ///
   /// Returns a list of [AuraTransaction] objects representing the transaction history.
   ///
   /// Throws an [AuraInternalError] if there's an error while fetching the transaction history.
   @override
   Future<List<AuraTransaction>> checkWalletHistory() async {
     try {
       String? bech32Address =
           await Storehouse.storage.getWalletAddress(walletName: walletName);
 
       List<AuraTransaction>? listSender = await _getListTransactionByAddress(
           bech32Address, AuraTransactionType.send);
       List<AuraTransaction>? listRecive = await _getListTransactionByAddress(
           bech32Address, AuraTransactionType.recive);
 
       List<AuraTransaction> listAllTransaction = [];
       listAllTransaction.addAll(listSender ?? []);
       listAllTransaction.addAll(listRecive ?? []);
 
       listAllTransaction.sort((a, b) {
         DateTime? aDate = DateTime.tryParse(a.timestamp);
         DateTime? bDate = DateTime.tryParse(b.timestamp);
         if (aDate == null || bDate == null) {
           return 0; // Skip
@@ -197,50 +233,52 @@ class AuraWalletImpl extends AuraWallet {
         queryData: queryData,
       );
 
       final cosMWasm.QuerySmartContractStateResponse response =
           await client.smartContractState(request);
 
       return String.fromCharCodes(response.data);
     } catch (e, s) {
       // Handle any exceptions that might occur during the query.
       throw AuraInternalError(ErrorCode.QueryFailed, 'Query failed: $e');
     }
   }
 
   /// Executes an interactive write operation on a smart contract located at [contractAddress].
   ///
   /// Throws an [AuraInternalError] with a specific error code and message if any validation fails.
   ///
   /// Returns the transaction hash if the operation is successful.
   @override
   Future<String> makeInteractiveWriteSmartContract({
     required String contractAddress,
     required Map<String, dynamic> executeMessage,
     List<int>? funds,
     int? fee,
   }) async {
+    _ensurePaymentsAllowed('Smart contract payment');
+
     // Validate the contract address.
     if (contractAddress.isEmpty) {
       throw AuraInternalError(
           ErrorCode.ContractAddressEmpty, 'Contract address is not empty');
     }
 
     // Validate the fee.
     if (fee != null && fee < 200) {
       throw AuraInternalError(ErrorCode.InvalidFee, 'Min fee is 200');
     }
 
     // Get the denomination from the environment.
     String denom = AuraWalletUtil.getDenom(environment);
 
     // Load the wallet passphrase.
     String? passPhrase =
         await Storehouse.storage.readWalletPassPhrase(walletName: walletName);
 
     // Check if the passphrase is null.
     if (passPhrase == null) {
       throw AuraInternalError(
           ErrorCode.PassphraseNotFound, 'Passphrase not found');
     }
 
     // Derive the wallet from the passphrase.
@@ -319,50 +357,52 @@ class AuraWalletImpl extends AuraWallet {
     } catch (e) {
       // Handle the error and throw an AuraInternalError with the appropriate error code and message.
       String message =
           e is PlatformException ? '[${e.code}] ${e.message}' : e.toString();
       throw AuraInternalError(ErrorCode.WalletPassphraseError, message);
     }
   }
 
   /// Creates and sends a transaction to the specified recipient.
   ///
   /// - [toAddress]: The recipient's address.
   /// - [amount]: The amount to send.
   /// - [fee]: The transaction fee.
   /// - [memo]: An optional memo for the transaction.
   ///
   /// Returns a [Tx] object representing the transaction.
   ///
   /// Throws an [AuraInternalError] with a specific error code and message if any error occurs.
   @override
   Future<Tx> makeTransaction({
     required String toAddress,
     required String amount,
     required String fee,
     String? memo,
   }) async {
+    _ensurePaymentsAllowed('Payment transaction');
+
     String denom = AuraWalletUtil.getDenom(environment);
 
     // Step #1: Create a message for the transaction.
     final MsgSend message = bank.MsgSend.create()
       ..fromAddress = bech32Address
       ..toAddress = toAddress;
     message.amount.add(Coin.create()
       ..denom = denom
       ..amount = amount);
 
     // Step #2: Create the transaction fee.
     final Fee feeData =
         AuraInAppWalletHelper.createFee(amount: fee, environment: environment);
 
     aura-core/
└── src/
    └── connectors/
        └── bifrost/
            __init__.py
            bifrost.py
            models.py
            store.py
            targets_http.py

 
