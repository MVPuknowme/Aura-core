name:MVPuknowme/aura
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/lib/src/entities/aura_wallet_impl.dart b/lib/src/entities/aura_wallet_impl.dart
index ade4ae644666ffed304534d03e061ae4f52876d6..1812d2564bb274980686329d394fa57c93b440ce 100644
--- a/lib/src/entities/aura_wallet_impl.dart
+++ b/lib/src/entities/aura_wallet_impl.dart
@@ -8,105 +8,141 @@ import 'package:flutter/services.dart';
 import '../../aura_environment.dart';
 import '../../wallet_objects.dart';
 
 import 'package:alan/proto/cosmos/bank/v1beta1/export.dart';
 import 'package:alan/proto/cosmos/bank/v1beta1/export.dart' as bank;
 import 'package:alan/proto/cosmwasm/wasm/v1/export.dart' as cosMWasm;
 import 'package:alan/proto/cosmos/tx/v1beta1/export.dart' as auraTx;
 
 import '../constants/error_constants.dart';
 import '../core/exceptions/aura_internal_exception.dart';
 import '../core/repo/store_house.dart';
 import '../core/utils/aura_inapp_wallet_helper.dart';
 import '../core/utils/grpc_logger.dart';
 
 class AuraWalletImpl extends AuraWallet {
   const AuraWalletImpl({
     required String walletName,
     required String bech32Address,
     required AuraWalletCoreEnvironment environment,
   }) : super(
           walletName: walletName,
           bech32Address: bech32Address,
           environment: environment,
         );
 
+  void _ensurePaymentsAllowed(String context) {
+    final String? errorMessage =
+        Storehouse.paymentRules.validationErrorMessage(context: context);
+
+    if (errorMessage != null) {
+      throw AuraInternalError(
+        ErrorCode.PaymentProcessingNotAllowed,
+        errorMessage,
+      );
+    }
+  }
+
   /// Submits a signed transaction to the blockchain network.
   ///
   /// Returns `true` if the transaction is successfully broadcasted, otherwise `false`.
   ///
   /// Throws an exception in case of any errors during the transaction submission.
   ///
   /// [signedTransaction]: The signed transaction to be broadcasted.
   ///
   @override
   Future<bool> submitTransaction({required Tx signedTransaction}) async {
     try {
+      _ensurePaymentsAllowed('Submit transaction');
+
       var networkInfo = Storehouse.networkInfo;
       final txSender = TxSender.fromNetworkInfo(networkInfo);
       final response = await txSender.broadcastTx(signedTransaction);
 
       return response.isSuccessful;
     } catch (e) {
       // Handle any exceptions that might occur during the transaction submission.
       return false;
     }
   }
 
   /// Retrieves the balance of the wallet associated with the provided [walletName].
   ///
   /// Returns the wallet balance as a string.
   ///
   /// Throws an [AuraInternalError] if there's an error while fetching the balance.
   @override
   Future<String> checkWalletBalance() async {
     try {
       String denom = AuraWalletUtil.getDenom(environment);
       String? bech32Address =
           await Storehouse.storage.getWalletAddress(walletName: walletName);
 
       final req =
           bank.QueryBalanceRequest(address: bech32Address, denom: denom);
       var networkInfo = Storehouse.networkInfo;
 
       final client =
           bank.QueryClient(networkInfo.gRPCChannel, interceptors: [LogInter()]);
 
       final response = await client.balance(req);
 
       return response.balance.amount;
     } catch (e) {
       // Handle any exceptions that might occur while fetching the balance.
       throw AuraInternalError(
           500, 'Error fetching wallet balance: ${e.toString()}');
     }
   }
 
   Future<bool> checkMnemonic({required String mnemonic}) async {
     return Bip39.validateMnemonic(mnemonic.split(' '));
   }
 
+  @override
+  Future<double> convertAmount({
+    required double amount,
+    required String targetCurrency,
+  }) async {
+    try {
+      return Storehouse.currencyConversionService.convert(
+        amount: amount,
+        targetCurrency: targetCurrency,
+      );
+    } catch (e) {
+      if (e is AuraInternalError) {
+        rethrow;
+      }
+
+      throw AuraInternalError(
+        ErrorCode.CurrencyConversionUnavailable,
+        'Failed to convert currency: $e',
+      );
+    }
+  }
+
   /// Retrieves the transaction history of the wallet associated with the provided [walletName].
   ///
   /// Returns a list of [AuraTransaction] objects representing the transaction history.
   ///
   /// Throws an [AuraInternalError] if there's an error while fetching the transaction history.
   @override
   Future<List<AuraTransaction>> checkWalletHistory() async {
     try {
       String? bech32Address =
           await Storehouse.storage.getWalletAddress(walletName: walletName);
 
       List<AuraTransaction>? listSender = await _getListTransactionByAddress(
           bech32Address, AuraTransactionType.send);
       List<AuraTransaction>? listRecive = await _getListTransactionByAddress(
           bech32Address, AuraTransactionType.recive);
 
       List<AuraTransaction> listAllTransaction = [];
       listAllTransaction.addAll(listSender ?? []);
       listAllTransaction.addAll(listRecive ?? []);
 
       listAllTransaction.sort((a, b) {
         DateTime? aDate = DateTime.tryParse(a.timestamp);
         DateTime? bDate = DateTime.tryParse(b.timestamp);
         if (aDate == null || bDate == null) {
           return 0; // Skip
@@ -197,50 +233,52 @@ class AuraWalletImpl extends AuraWallet {
         queryData: queryData,
       );
 
       final cosMWasm.QuerySmartContractStateResponse response =
           await client.smartContractState(request);
 
       return String.fromCharCodes(response.data);
     } catch (e, s) {
       // Handle any exceptions that might occur during the query.
       throw AuraInternalError(ErrorCode.QueryFailed, 'Query failed: $e');
     }
   }
 
   /// Executes an interactive write operation on a smart contract located at [contractAddress].
   ///
   /// Throws an [AuraInternalError] with a specific error code and message if any validation fails.
   ///
   /// Returns the transaction hash if the operation is successful.
   @override
   Future<String> makeInteractiveWriteSmartContract({
     required String contractAddress,
     required Map<String, dynamic> executeMessage,
     List<int>? funds,
     int? fee,
   }) async {
+    _ensurePaymentsAllowed('Smart contract payment');
+
     // Validate the contract address.
     if (contractAddress.isEmpty) {
       throw AuraInternalError(
           ErrorCode.ContractAddressEmpty, 'Contract address is not empty');
     }
 
     // Validate the fee.
     if (fee != null && fee < 200) {
       throw AuraInternalError(ErrorCode.InvalidFee, 'Min fee is 200');
     }
 
     // Get the denomination from the environment.
     String denom = AuraWalletUtil.getDenom(environment);
 
     // Load the wallet passphrase.
     String? passPhrase =
         await Storehouse.storage.readWalletPassPhrase(walletName: walletName);
 
     // Check if the passphrase is null.
     if (passPhrase == null) {
       throw AuraInternalError(
           ErrorCode.PassphraseNotFound, 'Passphrase not found');
     }
 
     // Derive the wallet from the passphrase.
@@ -319,50 +357,52 @@ class AuraWalletImpl extends AuraWallet {
     } catch (e) {
       // Handle the error and throw an AuraInternalError with the appropriate error code and message.
       String message =
           e is PlatformException ? '[${e.code}] ${e.message}' : e.toString();
       throw AuraInternalError(ErrorCode.WalletPassphraseError, message);
     }
   }
 
   /// Creates and sends a transaction to the specified recipient.
   ///
   /// - [toAddress]: The recipient's address.
   /// - [amount]: The amount to send.
   /// - [fee]: The transaction fee.
   /// - [memo]: An optional memo for the transaction.
   ///
   /// Returns a [Tx] object representing the transaction.
   ///
   /// Throws an [AuraInternalError] with a specific error code and message if any error occurs.
   @override
   Future<Tx> makeTransaction({
     required String toAddress,
     required String amount,
     required String fee,
     String? memo,
   }) async {
+    _ensurePaymentsAllowed('Payment transaction');
+
     String denom = AuraWalletUtil.getDenom(environment);
 
     // Step #1: Create a message for the transaction.
     final MsgSend message = bank.MsgSend.create()
       ..fromAddress = bech32Address
       ..toAddress = toAddress;
     message.amount.add(Coin.create()
       ..denom = denom
       ..amount = amount);
 
     // Step #2: Create the transaction fee.
     final Fee feeData =
         AuraInAppWalletHelper.createFee(amount: fee, environment: environment);
 
     var networkInfo = Storehouse.networkInfo;
 
     String? passPhrase =
         await Storehouse.storage.readWalletPassPhrase(walletName: walletName);
 
     if (passPhrase == null) {
       // Handle the case where the passphrase is null and throw an AuraInternalError.
       throw AuraInternalError(ErrorCode.NullPassphrase, "Passphrase is null");
     }
     final wallet = Wallet.derive(passPhrase.split(' '), Storehouse.networkInfo);
 
 
EOF
)
# Triggers on push to main and also on a schedule
on:
  push:
    branches:
      - main
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours UTC

jobs:
  aura_generation:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install openai

      - name: Run Aura Bridge
        run: python aura_bridge.py
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Commit and Push Changes
        run: |
          git config --global user.name "Aura Auto"
          git config --global user.email "aura@autogen.com"
          git add .
          git commit -m "Aura Bridge auto-generated code" || echo "No changes to commit"
          git push
